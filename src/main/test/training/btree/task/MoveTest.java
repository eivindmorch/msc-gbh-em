package training.btree.task;

import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;
import org.junit.jupiter.api.Test;
import util.Calculations;

import static org.junit.jupiter.api.Assertions.*;

class MoveTest {

//    private double calculateMovementAngle(Vector3D posVector1, Vector3D posVector2) {
//        Vector3D vectorBetweenUnits = posVector2.subtract(posVector1);
//        Vector3D vectorNorth = new Vector3D(0, 1, 0);
//        return Calculations.relativeBearing(vectorBetweenUnits, vectorNorth);
//    }
//
//    @Test
//    void calculateAngleTest1() {
//        Vector3D posVector1 = new Vector3D(0, 1,0);
//        Vector3D posVector2 = new Vector3D(1, 0,0);
//        assertEquals(360-90-45, calculateMovementAngle(posVector1, posVector2));
//    }
//
//    @Test
//    void calculateAngleTest2() {
//        Vector3D posVector1 = new Vector3D(0, 1,0);
//        Vector3D posVector2 = new Vector3D(-1, 0,0);
//        assertEquals(90+45, calculateMovementAngle(posVector1, posVector2));
//    }
//
//    @Test
//    void calculateAngleTest3() {
//        Vector3D posVector1 = new Vector3D(0, 1,0);
//        Vector3D posVector2 = new Vector3D(1, 0.5,0);
//        assertEquals(243.43494882292202, calculateMovementAngle(posVector1, posVector2));
//    }
//
//    @Test
//    void calculateAngleTest4() {
//        Vector3D posVector1 = new Vector3D(0, 0,0);
//        Vector3D posVector2 = new Vector3D(1, 0,0);
//        assertEquals(270, calculateMovementAngle(posVector1, posVector2));
//    }
//
//    @Test
//    void calculateAngleTest5() {
//        Vector3D posVector1 = new Vector3D(0, 0,0);
//        Vector3D posVector2 = new Vector3D(0, 1,0);
//        assertEquals(0, calculateMovementAngle(posVector1, posVector2));
//    }
//
//    @Test
//    void atan() {
//        assertEquals(Math.PI/2, Math.atan2(1, 0));
//    }


}